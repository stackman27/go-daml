package main

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/noders-team/go-daml/pkg/codec"
	"github.com/noders-team/go-daml/pkg/model"
	. "github.com/noders-team/go-daml/pkg/types"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
)

const SDKVersion = "2.9.1"

const packageName = "test-1.0.0"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args interface{}) map[string]interface{} {
	if args == nil {
		return map[string]interface{}{}
	}

	if m, ok := args.(map[string]interface{}); ok {
		return m
	}

	// Check if the type has a ToMap method
	type mapper interface {
		ToMap() map[string]interface{}
	}

	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]interface{}{
		"args": args,
	}
}

// Address is a variant/union type
type Address struct {
	US *USAddress `json:"US,omitempty"`
	UK *UKAddress `json:"UK,omitempty"`
}

// MarshalJSON implements custom JSON marshaling for Address
func (v Address) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(v)
}

// UnmarshalJSON implements custom JSON unmarshaling for Address
func (v *Address) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, v)
}

// GetVariantTag implements types.VARIANT interface
func (v Address) GetVariantTag() string {

	if v.US != nil {
		return "US"
	}

	if v.UK != nil {
		return "UK"
	}

	return ""
}

// GetVariantValue implements types.VARIANT interface
func (v Address) GetVariantValue() interface{} {

	if v.US != nil {
		return v.US
	}

	if v.UK != nil {
		return v.UK
	}

	return nil
}

// Verify interface implementation
var _ VARIANT = (*Address)(nil)

// American is a Template type
type American struct {
	Person  PARTY     `json:"person"`
	Address USAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t American) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Address", "American")
}

// CreateCommand returns a CreateCommand for this template
func (t American) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for American using JsonCodec
func (t American) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for American using JsonCodec
func (t *American) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for American

// Archive exercises the Archive choice on this American contract
func (t American) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Address", "American"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// Briton is a Template type
type Briton struct {
	Person  PARTY     `json:"person"`
	Address UKAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t Briton) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Address", "Briton")
}

// CreateCommand returns a CreateCommand for this template
func (t Briton) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for Briton using JsonCodec
func (t Briton) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for Briton using JsonCodec
func (t *Briton) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for Briton

// Archive exercises the Archive choice on this Briton contract
func (t Briton) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Address", "Briton"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFields is a Template type
type OptionalFields struct {
	Party  PARTY    `json:"party"`
	AMaybe OPTIONAL `json:"aMaybe"`
}

// GetTemplateID returns the template ID for this template
func (t OptionalFields) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "OptionalFields")
}

// CreateCommand returns a CreateCommand for this template
func (t OptionalFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["party"] = t.Party.ToMap()

	if t.AMaybe != nil {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": *t.AMaybe,
		}
	} else {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for OptionalFields using JsonCodec
func (t OptionalFields) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for OptionalFields using JsonCodec
func (t *OptionalFields) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for OptionalFields

// Archive exercises the Archive choice on this OptionalFields contract
func (t OptionalFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFieldsCleanUp exercises the OptionalFieldsCleanUp choice on this OptionalFields contract
func (t OptionalFields) OptionalFieldsCleanUp(contractID string, args OptionalFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "OptionalFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// OptionalFieldsCleanUp is a Record type
type OptionalFieldsCleanUp struct {
}

// ToMap converts OptionalFieldsCleanUp to a map for DAML arguments
func (t OptionalFieldsCleanUp) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	return m
}

// MarshalJSON implements custom JSON marshaling for OptionalFieldsCleanUp using JsonCodec
func (t OptionalFieldsCleanUp) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for OptionalFieldsCleanUp using JsonCodec
func (t *OptionalFieldsCleanUp) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Person is a Template type
type Person struct {
	Person  PARTY   `json:"person"`
	Address Address `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t Person) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Address", "Person")
}

// CreateCommand returns a CreateCommand for this template
func (t Person) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for Person using JsonCodec
func (t Person) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for Person using JsonCodec
func (t *Person) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for Person

// Archive exercises the Archive choice on this Person contract
func (t Person) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Address", "Person"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFields is a Template type
type SimpleFields struct {
	Party     PARTY     `json:"party"`
	ABool     BOOL      `json:"aBool"`
	AInt      INT64     `json:"aInt"`
	ADecimal  NUMERIC   `json:"aDecimal"`
	AText     TEXT      `json:"aText"`
	ADate     DATE      `json:"aDate"`
	ADatetime TIMESTAMP `json:"aDatetime"`
}

// GetTemplateID returns the template ID for this template
func (t SimpleFields) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "SimpleFields")
}

// CreateCommand returns a CreateCommand for this template
func (t SimpleFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["party"] = t.Party.ToMap()

	args["aBool"] = bool(t.ABool)

	args["aInt"] = int64(t.AInt)

	if t.ADecimal != nil {
		args["aDecimal"] = (*big.Int)(t.ADecimal)
	}

	args["aText"] = string(t.AText)

	args["aDate"] = t.ADate

	args["aDatetime"] = t.ADatetime

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for SimpleFields using JsonCodec
func (t SimpleFields) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for SimpleFields using JsonCodec
func (t *SimpleFields) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for SimpleFields

// SimpleFieldsCleanUp exercises the SimpleFieldsCleanUp choice on this SimpleFields contract
func (t SimpleFields) SimpleFieldsCleanUp(contractID string, args SimpleFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "SimpleFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// Archive exercises the Archive choice on this SimpleFields contract
func (t SimpleFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFieldsCleanUp is a Record type
type SimpleFieldsCleanUp struct {
}

// ToMap converts SimpleFieldsCleanUp to a map for DAML arguments
func (t SimpleFieldsCleanUp) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	return m
}

// MarshalJSON implements custom JSON marshaling for SimpleFieldsCleanUp using JsonCodec
func (t SimpleFieldsCleanUp) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for SimpleFieldsCleanUp using JsonCodec
func (t *SimpleFieldsCleanUp) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// UKAddress is a Record type
type UKAddress struct {
	Address  LIST     `json:"address"`
	Locality OPTIONAL `json:"locality"`
	City     TEXT     `json:"city"`
	State    TEXT     `json:"state"`
	Postcode TEXT     `json:"postcode"`
}

// ToMap converts UKAddress to a map for DAML arguments
func (t UKAddress) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["address"] = t.Address

	m["locality"] = t.Locality

	m["city"] = string(t.City)

	m["state"] = string(t.State)

	m["postcode"] = string(t.Postcode)

	return m
}

// MarshalJSON implements custom JSON marshaling for UKAddress using JsonCodec
func (t UKAddress) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for UKAddress using JsonCodec
func (t *UKAddress) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// USAddress is a Record type
type USAddress struct {
	Address LIST  `json:"address"`
	City    TEXT  `json:"city"`
	State   TEXT  `json:"state"`
	Zip     INT64 `json:"zip"`
}

// ToMap converts USAddress to a map for DAML arguments
func (t USAddress) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["address"] = t.Address

	m["city"] = string(t.City)

	m["state"] = string(t.State)

	m["zip"] = int64(t.Zip)

	return m
}

// MarshalJSON implements custom JSON marshaling for USAddress using JsonCodec
func (t USAddress) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for USAddress using JsonCodec
func (t *USAddress) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}
