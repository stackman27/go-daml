package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/noders-team/go-daml/pkg/model"
	. "github.com/noders-team/go-daml/pkg/types"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
)

const PackageID = "e2d906db3930143bfa53f43c7a69c218c8b499c03556485f312523090684ff34"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args interface{}) map[string]interface{} {
	if args == nil {
		return map[string]interface{}{}
	}

	if m, ok := args.(map[string]interface{}); ok {
		return m
	}

	// Check if the type has a toMap method
	type mapper interface {
		toMap() map[string]interface{}
	}

	if mapper, ok := args.(mapper); ok {
		return mapper.toMap()
	}

	return map[string]interface{}{
		"args": args,
	}
}

// Address is a variant/union type
type Address struct {
	Us *USAddress `json:"US,omitempty"`
	Uk *UKAddress `json:"UK,omitempty"`
}

// MarshalJSON implements custom JSON marshaling for Address
func (v Address) MarshalJSON() ([]byte, error) {

	if v.Us != nil {
		return json.Marshal(map[string]interface{}{
			"tag":   "US",
			"value": v.Us,
		})
	}

	if v.Uk != nil {
		return json.Marshal(map[string]interface{}{
			"tag":   "UK",
			"value": v.Uk,
		})
	}

	return json.Marshal(map[string]interface{}{})
}

// UnmarshalJSON implements custom JSON unmarshaling for Address
func (v *Address) UnmarshalJSON(data []byte) error {
	var tagged struct {
		Tag   string          `json:"tag"`
		Value json.RawMessage `json:"value"`
	}

	if err := json.Unmarshal(data, &tagged); err != nil {
		return err
	}

	switch tagged.Tag {

	case "US":
		var value USAddress
		if err := json.Unmarshal(tagged.Value, &value); err != nil {
			return err
		}
		v.Us = &value

	case "UK":
		var value UKAddress
		if err := json.Unmarshal(tagged.Value, &value); err != nil {
			return err
		}
		v.Uk = &value

	default:
		return fmt.Errorf("unknown tag: %s", tagged.Tag)
	}

	return nil
}

// GetVariantTag implements types.VARIANT interface
func (v Address) GetVariantTag() string {

	if v.Us != nil {
		return "US"
	}

	if v.Uk != nil {
		return "UK"
	}

	return ""
}

// GetVariantValue implements types.VARIANT interface
func (v Address) GetVariantValue() interface{} {

	if v.Us != nil {
		return v.Us
	}

	if v.Uk != nil {
		return v.Uk
	}

	return nil
}

// Verify interface implementation
var _ VARIANT = (*Address)(nil)

// American is a Template type
type American struct {
	Person  PARTY     `json:"person"`
	Address USAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t American) GetTemplateID() string {
	return fmt.Sprintf("%s:%s:%s", PackageID, "Address", "American")
}

// CreateCommand returns a CreateCommand for this template
func (t American) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// Choice methods for American

// Archive exercises the Archive choice on this American contract
func (t American) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Address", "American"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// Briton is a Template type
type Briton struct {
	Person  PARTY     `json:"person"`
	Address UKAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t Briton) GetTemplateID() string {
	return fmt.Sprintf("%s:%s:%s", PackageID, "Address", "Briton")
}

// CreateCommand returns a CreateCommand for this template
func (t Briton) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// Choice methods for Briton

// Archive exercises the Archive choice on this Briton contract
func (t Briton) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Address", "Briton"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFields is a Template type
type OptionalFields struct {
	Party  PARTY    `json:"party"`
	AMaybe OPTIONAL `json:"aMaybe"`
}

// GetTemplateID returns the template ID for this template
func (t OptionalFields) GetTemplateID() string {
	return fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "OptionalFields")
}

// CreateCommand returns a CreateCommand for this template
func (t OptionalFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["party"] = t.Party.ToMap()

	if t.AMaybe != nil {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": *t.AMaybe,
		}
	} else {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// Choice methods for OptionalFields

// Archive exercises the Archive choice on this OptionalFields contract
func (t OptionalFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFieldsCleanUp exercises the OptionalFieldsCleanUp choice on this OptionalFields contract
func (t OptionalFields) OptionalFieldsCleanUp(contractID string, args OptionalFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "OptionalFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// OptionalFieldsCleanUp is a Record type
type OptionalFieldsCleanUp struct {
}

// toMap converts OptionalFieldsCleanUp to a map for DAML arguments
func (t OptionalFieldsCleanUp) toMap() map[string]interface{} {
	return map[string]interface{}{}
}

// Person is a Template type
type Person struct {
	Person  PARTY   `json:"person"`
	Address Address `json:"address"`
}

// GetTemplateID returns the template ID for this template
func (t Person) GetTemplateID() string {
	return fmt.Sprintf("%s:%s:%s", PackageID, "Address", "Person")
}

// CreateCommand returns a CreateCommand for this template
func (t Person) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["person"] = t.Person.ToMap()

	args["address"] = t.Address

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// Choice methods for Person

// Archive exercises the Archive choice on this Person contract
func (t Person) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Address", "Person"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFields is a Template type
type SimpleFields struct {
	Party     PARTY     `json:"party"`
	ABool     BOOL      `json:"aBool"`
	AInt      INT64     `json:"aInt"`
	ADecimal  NUMERIC   `json:"aDecimal"`
	AText     TEXT      `json:"aText"`
	ADate     DATE      `json:"aDate"`
	ADatetime TIMESTAMP `json:"aDatetime"`
}

// GetTemplateID returns the template ID for this template
func (t SimpleFields) GetTemplateID() string {
	return fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "SimpleFields")
}

// CreateCommand returns a CreateCommand for this template
func (t SimpleFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["party"] = t.Party.ToMap()

	args["aBool"] = bool(t.ABool)

	args["aInt"] = int64(t.AInt)

	if t.ADecimal != nil {
		args["aDecimal"] = (*big.Int)(t.ADecimal)
	}

	args["aText"] = string(t.AText)

	args["aDate"] = t.ADate

	args["aDatetime"] = t.ADatetime

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// Choice methods for SimpleFields

// SimpleFieldsCleanUp exercises the SimpleFieldsCleanUp choice on this SimpleFields contract
func (t SimpleFields) SimpleFieldsCleanUp(contractID string, args SimpleFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "SimpleFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// Archive exercises the Archive choice on this SimpleFields contract
func (t SimpleFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("%s:%s:%s", PackageID, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFieldsCleanUp is a Record type
type SimpleFieldsCleanUp struct {
}

// toMap converts SimpleFieldsCleanUp to a map for DAML arguments
func (t SimpleFieldsCleanUp) toMap() map[string]interface{} {
	return map[string]interface{}{}
}

// UKAddress is a Record type
type UKAddress struct {
	Address  LIST     `json:"address"`
	Locality OPTIONAL `json:"locality"`
	City     TEXT     `json:"city"`
	State    TEXT     `json:"state"`
	Postcode TEXT     `json:"postcode"`
}

// toMap converts UKAddress to a map for DAML arguments
func (t UKAddress) toMap() map[string]interface{} {
	return map[string]interface{}{

		"address":  t.Address,
		"locality": t.Locality,
		"city":     string(t.City),
		"state":    string(t.State),
		"postcode": string(t.Postcode),
	}
}

// USAddress is a Record type
type USAddress struct {
	Address LIST  `json:"address"`
	City    TEXT  `json:"city"`
	State   TEXT  `json:"state"`
	Zip     INT64 `json:"zip"`
}

// toMap converts USAddress to a map for DAML arguments
func (t USAddress) toMap() map[string]interface{} {
	return map[string]interface{}{

		"address": t.Address,
		"city":    string(t.City),
		"state":   string(t.State),
		"zip":     int64(t.Zip),
	}
}
