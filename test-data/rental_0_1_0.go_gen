package main

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/noders-team/go-daml/pkg/codec"
	"github.com/noders-team/go-daml/pkg/model"
	. "github.com/noders-team/go-daml/pkg/types"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
)

const SDKVersion = "1.18.1"

const packageName = "rental-0.1.0"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args interface{}) map[string]interface{} {
	if args == nil {
		return map[string]interface{}{}
	}

	if m, ok := args.(map[string]interface{}); ok {
		return m
	}

	// Check if the type has a ToMap method
	type mapper interface {
		ToMap() map[string]interface{}
	}

	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]interface{}{
		"args": args,
	}
}

// Accept is a Record type
type Accept struct {
	Foo TEXT  `json:"foo"`
	Bar INT64 `json:"bar"`
}

// ToMap converts Accept to a map for DAML arguments
func (t Accept) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["foo"] = string(t.Foo)

	m["bar"] = int64(t.Bar)

	return m
}

// MarshalJSON implements custom JSON marshaling for Accept using JsonCodec
func (t Accept) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for Accept using JsonCodec
func (t *Accept) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// RentalAgreement is a Template type
type RentalAgreement struct {
	Landlord PARTY `json:"landlord"`
	Tenant   PARTY `json:"tenant"`
	Terms    TEXT  `json:"terms"`
}

// GetTemplateID returns the template ID for this template
func (t RentalAgreement) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Rental", "RentalAgreement")
}

// CreateCommand returns a CreateCommand for this template
func (t RentalAgreement) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["landlord"] = t.Landlord.ToMap()

	args["tenant"] = t.Tenant.ToMap()

	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for RentalAgreement using JsonCodec
func (t RentalAgreement) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for RentalAgreement using JsonCodec
func (t *RentalAgreement) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for RentalAgreement

// Archive exercises the Archive choice on this RentalAgreement contract
func (t RentalAgreement) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Rental", "RentalAgreement"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// RentalProposal is a Template type
type RentalProposal struct {
	Landlord PARTY `json:"landlord"`
	Tenant   PARTY `json:"tenant"`
	Terms    TEXT  `json:"terms"`
}

// GetTemplateID returns the template ID for this template
func (t RentalProposal) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", packageName, "Rental", "RentalProposal")
}

// CreateCommand returns a CreateCommand for this template
func (t RentalProposal) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	args["landlord"] = t.Landlord.ToMap()

	args["tenant"] = t.Tenant.ToMap()

	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// MarshalJSON implements custom JSON marshaling for RentalProposal using JsonCodec
func (t RentalProposal) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

// UnmarshalJSON implements custom JSON unmarshaling for RentalProposal using JsonCodec
func (t *RentalProposal) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for RentalProposal

// Archive exercises the Archive choice on this RentalProposal contract
func (t RentalProposal) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// Accept exercises the Accept choice on this RentalProposal contract
func (t RentalProposal) Accept(contractID string, args Accept) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageName, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Accept",
		Arguments:  argsToMap(args),
	}
}
